package v1

// Analysis represents a comprehensive, structured breakdown of a builtin error,
// providing detailed information for understanding, logging, and debugging.
// It is typically generated by an error analysis function (e.g., [Analyze]).
type Analysis struct {
	// Message provides a human-readable summary or a user-friendly description of the error.
	// This can be directly displayed to users or included in logs.
	Message string

	// Label categorizes the error, often indicating its type, domain, or origin.
	// This helps in classifying and filtering errors using [errors.Is] in different
	// layers of the application. You can add a Label to an error using [Tag] option in [New] function.
	Label Label // Assuming Label is an enum or string type representing error categories

	// Cause is the underlying original error that could be wrapped in an error using [Because] as an
	// option in [New] function, if applicable. comparing the returned error with the Cause using [errors.Is]
	// leads to true.
	Cause error

	// Diagnosis holds specific, technical diagnostic details about the error,
	// including a detailed note describing the issue and its associated Severity level.
	// This field is typically populated when the error is created with a [Diagnosis] option in [New] function.
	Diagnosis Diagnosis

	// Metadata contains any additional, structured data related to the error
	// that might be useful for context, correlation, or further investigation,
	// but doesn't fit into the predefined error fields. It could be attached to an error using
	// [Metadata] option in [New] function.
	Metadata any
}

// Analyze processes an error, breaking it down into its constituent parts
// and providing structured information for debugging, logging, or display.
func Analyze(input error) *Analysis {
	if input == nil {
		return nil
	}
	result := &Analysis{
		Label:   Untagged,
		Message: input.Error(),
	}
	switch err := input.(type) {
	case *MetaError:
		if err.metadata != nil {
			result.Metadata = err.metadata
		}
		return result

	case *StandardError:
		if err.label != nil {
			result.Label = err.label
		}
		if err.cause != nil {
			result.Cause = err.cause
		}
		result.Diagnosis = err.diagnosis
		return result

	case *RichError:
		if err.label != nil {
			result.Label = err.label
		}
		if err.cause != nil {
			result.Cause = err.cause
		}
		result.Diagnosis = err.diagnosis
		if err.metadata != nil {
			result.Metadata = err.metadata
		}
		return result

	default:
		return result
	}
}
